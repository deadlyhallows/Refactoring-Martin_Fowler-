* Pointers for Refactoring

1. Add "tests" to the code wherever absent:

    a. Make sure all tests are fully automatic and that they check their own results, use "assert"
    b. A suite of tests is a powerful "bug detector" that decapitates the time it takes to find bugs.
    c. Run your tests frequently. Localize tests whenever you compileâ€”"every test at least every day".
    d. When you get a bug report, start by writing a unit test that exposes the bug.
    e. It is better to write and run incomplete tests than not to run complete tests.
    f. Think of the "boundary conditions" under which things might go wrong and concentrate your tests there.
    g. Don't let the fear that testing can't catch all bugs stop you from writing the tests that will catch most bugs.
    h. Don't forget to "test that exceptions are raised" when things are expected to go wrong.

2. Look for long methods which can be converted to small ones: "Extract Method"

    a. start with extracting logical part from the long method
    b. look for local variables, unchanged ones will be parameters to the extracted method and the changing ones will
       be local variables which wil be returned.

3. "Rename the variables and functions" in a way that it explains the purpose of the code, also add doc-strings wherever
   needed.

4. Check if methods of all classes uses the data of the same class, and move the methods accordingly.
   After this, change the references of old method: "Move Method"

5. "Replace "temp" variables with queries" if they are adding to the params used to call a function.

6. convert switch or if-else statements to separate classes using polymorphism (strategy pattern).

=======================================================================================================================

* Pointers for OOP in Python

1. class methods and variables
2. access modifiers (public, protect, private)